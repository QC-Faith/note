# 左右值算法实现组织架构树的构建和查询

------

## 1. 左右值算法实现方案

**实现思路**

左右值算法通过为每个节点分配两个数值（左值和右值）来表示其在树中的位置，从而避免深度递归。每个节点的左值和右值定义如下：

- **左值（lft）**：表示节点在树中的左边界，子树中的所有节点左值均大于等于父节点的左值。
- **右值（rgt）**：表示节点在树中的右边界，子树中的所有节点右值均小于等于父节点的右值。
- **层级（level）**：可选字段，表示节点在树中的深度，用于辅助查询。
- **节点之间的关联**：通过左值和右值的关系判断上下级关系，而无需递归遍历整个树。

**算法步骤**

1. **初始化树结构**：
   - 遍历组织架构树，从根节点开始，分配左值和右值。
   - 根节点设为 (lft=1, rgt=2n)，其中 n 为节点总数。
   - 每次进入子节点时分配左值，退出时分配右值。
2. **构建数据库表**：
   - 创建表存储节点信息，包括 id（唯一标识）、name（部门名称）、lft（左值）、rgt（右值）、level（层级）。
3. **查询逻辑**：
   - **查询子部门**：查找 lft > 父节点lft AND rgt < 父节点rgt 的节点。
   - **查询父部门**：查找包含当前节点左值和右值的节点中层级最低的。
   - **查询所有上级**：从当前节点向上查找，直到根节点。

**示例图与数据**

假设组织架构树如下：

```text
       公司 (1, 12, 0)
      /      \
  部门A (2, 5, 1)  部门B (6, 11, 1)
   /         \
部门A1 (3, 4, 2)  部门B1 (7, 10, 2)
                \
                部门B1a (8, 9, 3)
```

- **图示**：

  ```text
  公司 (1, 12, 0)
  ├── 部门A (2, 5, 1)
  │   └── 部门A1 (3, 4, 2)
  └── 部门B (6, 11, 1)
      └── 部门B1 (7, 10, 2)
          └── 部门B1a (8, 9, 3)
  ```

- **数据表**：

  | id   | name    | lft  | rgt  | level |
  | ---- | ------- | ---- | ---- | ----- |
  | 1    | 公司    | 1    | 12   | 0     |
  | 2    | 部门A   | 2    | 5    | 1     |
  | 3    | 部门A1  | 3    | 4    | 2     |
  | 4    | 部门B   | 6    | 11   | 1     |
  | 5    | 部门B1  | 7    | 10   | 2     |
  | 6    | 部门B1a | 8    | 9    | 3     |

- **关联方式**：  

  - 部门A (2, 5) 包含子部门A1 (3, 4)，因为 2 < 3 < 4 < 5。
  - 公司 (1, 12) 包含所有子部门，因为 1 < lft < rgt < 12。

**SQL 示例**

- **查询部门A的子部门**：

  sql

  ```sql
  SELECT name FROM tree_table WHERE lft > 2 AND rgt < 5;
  ```

  结果：部门A1

- **查询部门B1的所有上级**：

  sql

  ```sql
  SELECT name FROM tree_table WHERE lft < 7 AND rgt > 10 ORDER BY level;
  ```

  结果：公司、部门B

------

## 2. 没有使用左右值法时的递归问题场景

**传统递归实现**

在没有使用左右值法时，组织架构树的上下级查询通常依赖递归遍历。例如，使用父子关系表（parent_id）存储上下级关系。

**数据结构**

- **表结构**：

  | id   | name    | parent_id |
  | ---- | ------- | --------- |
  | 1    | 公司    | NULL      |
  | 2    | 部门A   | 1         |
  | 3    | 部门A1  | 2         |
  | 4    | 部门B   | 1         |
  | 5    | 部门B1  | 4         |
  | 6    | 部门B1a | 5         |

- **图示**：

  ```text
  公司 (id=1)
  ├── 部门A (id=2)
  │   └── 部门A1 (id=3)
  └── 部门B (id=4)
      └── 部门B1 (id=5)
          └── 部门B1a (id=6)
  ```

- **关联方式**：通过 parent_id 字段指向父节点，查询时需递归遍历。

**递归查询问题场景**

- **查询子部门**：

  - 从部门B (id=4) 查询所有子部门，需要递归查找 parent_id = 4 的节点，再递归其子节点。

  - SQL 示例（使用递归CTE）：

    sql

    ```sql
    WITH RECURSIVE subordinates AS (
        SELECT id, name FROM tree_table WHERE id = 4
        UNION ALL
        SELECT t.id, t.name FROM tree_table t
        INNER JOIN subordinates s ON t.parent_id = s.id
    )
    SELECT name FROM subordinates;
    ```

    结果：部门B、部门B1、部门B1a

- **查询所有上级**：

  - 从部门B1a (id=6) 查询所有上级，需要递归向上查找 id = parent_id。

  - SQL 示例：

    sql

    ```sql
    WITH RECURSIVE ancestors AS (
        SELECT id, name FROM tree_table WHERE id = 6
        UNION ALL
        SELECT t.id, t.name FROM tree_table t
        INNER JOIN ancestors a ON t.id = a.parent_id
    )
    SELECT name FROM ancestors;
    ```

    结果：部门B1a、部门B1、部门B、公司

**问题**

1. **性能问题**：  
   - 递归查询在树深或节点数较多时，性能下降明显，尤其是数据库中数据量大时，递归操作可能导致查询超时。
2. **深度限制**：  
   - 某些数据库（如 MySQL）对递归深度有上限（默认1000层），深层组织架构可能因超限失败。
3. **维护复杂性**：  
   - 添加或删除节点时需更新所有相关节点的 parent_id，容易出错或导致数据不一致。
4. **实时性差**：  
   - 每次查询都需要从头递归，难以支持大规模实时查询。

------

## 3. 使用左右值法后的优势

1. **避免递归**：  
   - 通过左值和右值直接计算上下级关系，查询效率高，消除递归导致的栈溢出风险。
   - SQL 查询是单次操作，性能稳定。
2. **性能优化**：  
   - 索引优化后，左值和右值范围查询速度快，O(1) 或 O(log n) 复杂度，远优于递归的 O(n)。
3. **维护简单**：  
   - 添加或删除节点时，只需调整受影响节点的左值和右值范围，不需要更新整个树结构。
   - 例如，删除部门A1，只需删除 (3, 4) 记录，并更新部门A的右值为4。
4. **支持复杂查询**：  
   - 易于查询子树、祖先或同级节点，例如统计某个部门下的总人数或层级关系。
   - 示例：查询公司下所有部门的员工数，可直接通过 lft 和 rgt 范围汇总。
5. **数据一致性**：  
   - 左值和右值关系明确，减少因递归或手动维护导致的数据不一致风险。

------

总结

- **实现方案**：使用左右值算法，通过分配左值和右值构建组织架构树，示例图展示了部门间的层级关系，查询通过 SQL 范围条件实现。
- **递归问题**：传统父子关系表依赖递归，存在性能瓶颈、深度限制和维护复杂性，示例图展示了基于 parent_id 的关联方式。
- **优势**：避免递归、性能优化、维护简单、支持复杂查询、数据一致性强。