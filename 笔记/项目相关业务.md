# 左右值算法实现组织架构树的构建和查询

------

## 1. 左右值算法实现方案

**实现思路**

左右值算法通过为每个节点分配两个数值（左值和右值）来表示其在树中的位置，从而避免深度递归。每个节点的左值和右值定义如下：

- **左值（lft）**：表示节点在树中的左边界，子树中的所有节点左值均大于等于父节点的左值。
- **右值（rgt）**：表示节点在树中的右边界，子树中的所有节点右值均小于等于父节点的右值。
- **层级（level）**：可选字段，表示节点在树中的深度，用于辅助查询。
- **节点之间的关联**：通过左值和右值的关系判断上下级关系，而无需递归遍历整个树。

**算法步骤**

1. **初始化树结构**：
   - 遍历组织架构树，从根节点开始，分配左值和右值。
   - 根节点设为 (lft=1, rgt=2n)，其中 n 为节点总数。
   - 每次进入子节点时分配左值，退出时分配右值。
2. **构建数据库表**：
   - 创建表存储节点信息，包括 id（唯一标识）、name（部门名称）、lft（左值）、rgt（右值）、level（层级）。
3. **查询逻辑**：
   - **查询子部门**：查找 lft > 父节点lft AND rgt < 父节点rgt 的节点。
   - **查询父部门**：查找包含当前节点左值和右值的节点中层级最低的。
   - **查询所有上级**：从当前节点向上查找，直到根节点。

**示例图与数据**

假设组织架构树如下：

```text
       公司 (1, 12, 0)
      /            \
  部门A (2, 5, 1)  部门B (6, 11, 1)
   /                  \
部门A1 (3, 4, 2)    部门B1 (7, 10, 2)
                         \
                       部门B1a (8, 9, 3)
```

- **图示**：

  ```text
  公司 (1, 12, 0)
  ├── 部门A (2, 5, 1)
  │   │
  │   └── 部门A1 (3, 4, 2)
  │
  └── 部门B (6, 11, 1)
  	│
      └── 部门B1 (7, 10, 2)
      	│
          └── 部门B1a (8, 9, 3)
  ```

- **数据表**：

  | id   | name    | lft  | rgt  | level |
  | ---- | ------- | ---- | ---- | ----- |
  | 1    | 公司    | 1    | 12   | 0     |
  | 2    | 部门A   | 2    | 5    | 1     |
  | 3    | 部门A1  | 3    | 4    | 2     |
  | 4    | 部门B   | 6    | 11   | 1     |
  | 5    | 部门B1  | 7    | 10   | 2     |
  | 6    | 部门B1a | 8    | 9    | 3     |

- **关联方式**：  

  - 部门A (2, 5) 包含子部门A1 (3, 4)，因为 2 < 3 < 4 < 5。
  - 公司 (1, 12) 包含所有子部门，因为 1 < lft < rgt < 12。

**SQL 示例**

- **查询部门A的子部门**：

  sql

  ```sql
  SELECT name FROM tree_table WHERE lft > 2 AND rgt < 5;
  ```

  结果：部门A1

- **查询部门B1的所有上级**：

  sql

  ```sql
  SELECT name FROM tree_table WHERE lft < 7 AND rgt > 10 ORDER BY level;
  ```

  结果：公司、部门B

------

## 2. 没有使用左右值法时的递归问题场景

**传统递归实现**

在没有使用左右值法时，组织架构树的上下级查询通常依赖递归遍历。例如，使用父子关系表（parent_id）存储上下级关系。

**数据结构**

- **表结构**：

  | id   | name    | parent_id |
  | ---- | ------- | --------- |
  | 1    | 公司    | NULL      |
  | 2    | 部门A   | 1         |
  | 3    | 部门A1  | 2         |
  | 4    | 部门B   | 1         |
  | 5    | 部门B1  | 4         |
  | 6    | 部门B1a | 5         |

- **图示**：

  ```text
  公司 (id=1)
  ├── 部门A (id=2)
  │   └── 部门A1 (id=3)
  └── 部门B (id=4)
      └── 部门B1 (id=5)
          └── 部门B1a (id=6)
  ```

- **关联方式**：通过 parent_id 字段指向父节点，查询时需递归遍历。

**递归查询问题场景**

- **查询子部门**：

  - 从部门B (id=4) 查询所有子部门，需要递归查找 parent_id = 4 的节点，再递归其子节点。

  - SQL 示例（使用递归CTE）：

    sql

    ```sql
    WITH RECURSIVE subordinates AS (
        SELECT id, name FROM tree_table WHERE id = 4
        UNION ALL
        SELECT t.id, t.name FROM tree_table t
        INNER JOIN subordinates s ON t.parent_id = s.id
    )
    SELECT name FROM subordinates;
    ```

    结果：部门B、部门B1、部门B1a

- **查询所有上级**：

  - 从部门B1a (id=6) 查询所有上级，需要递归向上查找 id = parent_id。

  - SQL 示例：

    sql

    ```sql
    WITH RECURSIVE ancestors AS (
        SELECT id, name FROM tree_table WHERE id = 6
        UNION ALL
        SELECT t.id, t.name FROM tree_table t
        INNER JOIN ancestors a ON t.id = a.parent_id
    )
    SELECT name FROM ancestors;
    ```

    结果：部门B1a、部门B1、部门B、公司

**问题**

1. **性能问题**：  
   - 递归查询在树深或节点数较多时，性能下降明显，尤其是数据库中数据量大时，递归操作可能导致查询超时。
2. **深度限制**：  
   - 某些数据库（如 MySQL）对递归深度有上限（默认1000层），深层组织架构可能因超限失败。
3. **维护复杂性**：  
   - 添加或删除节点时需更新所有相关节点的 parent_id，容易出错或导致数据不一致。
4. **实时性差**：  
   - 每次查询都需要从头递归，难以支持大规模实时查询。

------

## 3. 使用左右值法后的优势

1. **避免递归**：  
   - 通过左值和右值直接计算上下级关系，查询效率高，消除递归导致的栈溢出风险。
   - SQL 查询是单次操作，性能稳定。
2. **性能优化**：  
   - 索引优化后，左值和右值范围查询速度快，O(1) 或 O(log n) 复杂度，远优于递归的 O(n)。
3. **维护简单**：  
   - 添加或删除节点时，只需调整受影响节点的左值和右值范围，不需要更新整个树结构。
   - 例如，删除部门A1，只需删除 (3, 4) 记录，并更新部门A的右值为4。
4. **支持复杂查询**：  
   - 易于查询子树、祖先或同级节点，例如统计某个部门下的总人数或层级关系。
   - 示例：查询公司下所有部门的员工数，可直接通过 lft 和 rgt 范围汇总。
5. **数据一致性**：  
   - 左值和右值关系明确，减少因递归或手动维护导致的数据不一致风险。

------

总结

- **实现方案**：使用左右值算法，通过分配左值和右值构建组织架构树，示例图展示了部门间的层级关系，查询通过 SQL 范围条件实现。
- **递归问题**：传统父子关系表依赖递归，存在性能瓶颈、深度限制和维护复杂性，示例图展示了基于 parent_id 的关联方式。
- **优势**：避免递归、性能优化、维护简单、支持复杂查询、数据一致性强。

# 抽奖算法

## 别名采样算法（Alias Method）

- 原理：别名采样算法通过预处理将概率分布转化为一个表格，使得每次抽奖的时间复杂度降为O(1)。它将每个奖品的概率分配到n个等高的“柱子”中，每个柱子包含主事件和别名事件，通过随机选择柱子并根据概率决定结果。

- 实现步骤：想象n个等高的柱子，每个柱子代表1/n的概率。别名算法的核心思想是：

  1. 将不同奖品的概率分配到这些等高的柱子中
  2. 每个柱子最多包含两种可能的奖品：主奖品和别名奖品
  3. 抽奖时，生成两个随机数（i 和 j），先随机选择一个柱子（随机数 i），再决定是获得主奖品还是别名奖品（随机数 j）

- 利

  - 高效性：查询时间为O(1)，非常适合高频抽奖。

  - 稳定性：结果严格符合概率分布。

  - 预处理：只需一次性构建别名表，后续抽奖无需重新计算。

- 弊

  - 预处理成本：初始化需要O(n)时间和空间，n为奖品类别数（这里是5）。若奖品类别频繁变动，需重新构建表。

  - 复杂性：实现较其他方法稍复杂。

------

## 轮盘赌算法

- 原理：将概率分布想象成一个轮盘，每个奖品占据一段长度与概率成正比的区间。生成一个0到1之间的随机数，判断它落在哪个区间。

- 实现步骤

  1. 计算累积概率：未中奖0.3, A:0.35, B:0.45, C:0.65, D:1.0。
  2. 生成随机数r（0到1）。
  3. 遍历累积概率数组，找到r落入的区间。

- 利

  - 简单性：实现非常直观，代码简单。

  - 灵活性：无需预处理，适合概率分布动态变化的场景。

- 弊

  - 效率较低：时间复杂度为O(n)，n为奖品类别数（这里是5）。在高频抽奖下性能不如别名采样。

  - 线性搜索：若奖品类别增多，遍历时间会线性增加。

## 二分搜索法

- 原理：基于轮盘赌算法的改进版，将累积概率数组预计算好，然后使用二分搜索快速定位随机数落入的区间。

- 实现步骤

  1. 预计算累积概率数组：未中奖0.3, A:0.35, B:0.45, C:0.65, D:1.0。
  2. 生成随机数r（0到1）。
  3. 用二分搜索找到r所在的区间。

- 利

  - 高效性：查询时间为O(log n)，比轮盘赌的O(n)更快。

  - 简单性：基于累积概率的预处理简单，二分搜索是标准算法。

- 弊

  - 预处理成本：需要O(n)时间预计算累积概率，若概率频繁变动需重新计算。

  - 复杂度：比轮盘赌稍复杂，但比别名采样简单。

## 最终选择：别名采样算法

理由：在抽奖场景中：

- **性能优势**：抽奖是一个线上活动，需要处理大量用户抽奖请求，别名采样O(1)的查询效率远超其他算法。
- **一次性预处理**：奖品和概率（0.05/0.1/0.2/0.35/0.3）是固定的，预处理成本仅在初始化时发生一次，后续无需调整。
- **空间效率**：只有5个类别（ABCD+未中奖），别名表构建成本低，内存占用极小，空间复杂度可接受。

对比分析

- 轮盘赌适合奖品种类少且概率经常变动的简单系统，但O(n)效率在高并发场景下会成为瓶颈。
- 二分查找优化的轮盘赌是一个良好的中间选择，当无法承受别名采样的实现复杂性时可考虑
- 别名采样完美平衡了预处理成本和查询效率，特别适合固定概率的高频抽奖。
