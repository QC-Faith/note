# 订单30分钟取消

1. 定时任务

   基于Timer、ScheduledThreadPoolExecutor、或者像xxl-job这类调度框架都能实现

   > <font color='Apricot'>缺点：</font>
   >
   > 1、<font color='Chestnut Red'>**时间不精准**</font>。  一般定时任务基于固定的频率、按照时间定时执行的，那么就可能会发生很多订单已经到了超时时间，但是定时任务的调度时间还没到，那么就会导致这些订单的实际关闭时间要比应该关闭的时间晚一些。
   >
   > 2、<font color='Chestnut Red'>**无法处理大订单量**</font>。  定时任务的方式是会把本来比较分散的关闭时间集中到任务调度的那一段时间，如果订单量比较大的话，那么就可能导致任务执行时间很长，整个任务的时间越长，订单被扫描到时间可能就很晚，那么就会导致关闭时间更晚。
   >
   > 3、<font color='Chestnut Red'>**对数据库造成压力**</font>。 定时任务集中扫表，这会使得数据库IO在短时间内被大量占用和消耗，如果没有做好隔离，并且业务量比较大的话，就可能会影响到线上的正常业务。
   >
   > 4、<font color='Chestnut Red'>**分库分表问题**</font>。 订单系统，一旦订单量大就可能会考虑分库分表，在分库分表中进行全表扫描，这是一个极不推荐的方案。
   >
   > 所以，定时任务的方案，适合于对时间精确度要求不高、并且业务量不是很大的场景中。如果对时间精度要求比较高，并且业务量很大的话，这种方案不适用。

2. JDK自带的延迟队列

   DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。

   > <font color='Apricot'>实现方案：</font>
   >
   > 基于延迟队列，是可以实现订单的延迟关闭的，首先，在用户创建订单的时候，把订单加入到DelayQueue中，然后，还需要一个常驻任务不断的从队列中取出那些到了超时时间的订单，然后在把他们进行关单，之后再从队列中删除掉。
   >
   > 这个方案需要有一个线程，不断的从队列中取出需要关单的订单。一般在这个线程中需要加一个while(true)循环，这样才能确保任务不断的执行并且能够及时的取出超时订单。
   >
   > <font color='Apricot'>优点：</font> 实现起来简单，不须要依赖第三方的框架和类库，JDK原生就支持了。
   >
   > <font color='Apricot'>缺点：</font> 首先，基于DelayQueue的话，需要把订单放进去，那如果订单量太大的话，可能会导致OOM的问题；另外，DelayQueue是基于JVM内存的，一旦机器重启了，里面的数据就都没有了。虽然我们可以配合数据库的持久化一起使用。而且现在很多应用都是集群部署的，那么集群中多个实例上的多个DelayQueue如何配合是一个很大的问题。
   >
   > 所以，<font color='Peach'>基于JDK的DelayQueue方案只适合在单机场景、并且数据量不大的场景中使用，如果涉及到分布式场景，那还是不建议使用。</font>

3. Netty的时间轮

   和上面JDK自带的DelayQueue类似的方式，那就是基于时间轮实现。主要是因为

   >  时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。

   基于Netty的HashedWheelTimer可以帮助我们快速的实现一个时间轮，这种方式和DelayQueue类似

   > <font color='Apricot'>缺点：</font> 都是基于内存，服务器重启后，数据全部消失，怕宕机；集群扩展麻烦；内存有限制，订单数太多，很容易OOM。
   >
   > <font color='Apricot'>优点：</font> 相比DelayQueue的话，效率更高一些，任务触发的延迟更低，DelayQueue插入和删除操作的平均时间复杂度——O(nlog(n))，虽然已经挺好的了，但是<font color='Sol Spray'>时间轮的方案可以将插入和删除操作的时间复杂度都降为O(1)</font>。代码实现上面也更加精简。

   所以，<font color='Peach'>基于Netty的时间轮方案比基于JDK的DelayQueue效率更高，实现起来更简单，但是同样的，只适合在单机场景、并且数据量不大的场景中使用，如果涉及到分布式场景，那还是不建议使用。</font>

4. Kafka的时间轮

   Kafka内部有很多延时性的操作，如延时生产，延时拉取，延时数据删除等，这些延时功能由内部的延时操作管理器来做专门的处理，其底层是采用时间轮实现.

   为了解决有一些时间跨度大的延时任务，Kafka 还引入了层级时间轮，能更好控制时间粒度，可以应对更加复杂的定时任务处理场景；

   Kafka 中的时间轮的实现是 TimingWheel 类，位于 kafka.utils.timer 包中。基于Kafka的时间轮同样可以得到<font color='Peach'>O(1)时间复杂度</font>，性能上还是不错的。

   > <font color='Apricot'>缺点：</font> 在实现方式上有点复杂，需要依赖kafka
   >
   > <font color='Apricot'>优点：</font> 稳定性和性能都要更高一些，而且适合用在分布式场景中。

5. RocketMQ延迟消息

   相比于Kafka来说，RocketMQ中有一个强大的功能，那就是支持延迟消息（当消息写入到Broker后，不会立刻被消费者消费，需要等待指定的时长后才可被消费处理的消息，称为延时消息）。

   > <font color='Apricot'>实现方式：</font>
   >
   > 有了延迟消息，我们就可以在订单创建好之后，发送一个延迟消息，比如20分钟取消订单，那就发一个延迟20分钟的延迟消息，然后在20分钟之后，消息就会被消费者消费，消费者在接收到消息之后，去关单就行了。
   >
   > <font color='Apricot'>缺点：</font> 非商业版的RocketMQ的延迟消息并不是支持任意时长的延迟的，它只支持：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h这几个时长。

   可以看到，有了RocketMQ延迟消息之后，我们处理上就简单很多，只需要发消息，和接收消息就行了，系统之间完全解耦了。但是因为延迟消息的时长受到了限制，所以并不是很灵活。

   <font color='Peach'>如果我们的业务上，关单时长刚好和RocketMQ延迟消息支持的时长匹配的话，那么是可以基于RocketMQ延迟消息来实现的。否则，这种方式并不是最佳的。</font>

6. RabbitMQ死信队列

   延迟消息不仅在RocketMQ中支持，其实在RabbitMQ中也是可以实现的，只不过其底层是基于死信队列实现的。

   > 当RabbitMQ中的一条正常的消息，因为过了存活时间（TTL过期）、队列长度超限、被消费者拒绝等原因无法被消费时，就会变成Dead Message，即死信。

   当一个消息变成死信之后，他就能被重新发送到死信队列中（其实是交换机-exchange）。那么基于这样的机制，就可以实现延迟消息了。

   > <font color='Apricot'>实现方式：</font>
   >
   > 我们给一个消息设定TTL，然但是并不消费这个消息，等他过期，过期后就会进入到死信队列，然后我们再监听死信队列的消息消费就行了。而且，RabbitMQ中的这个TTL是可以设置任意时长的，这就解决了RocketMQ的不灵活的问题。
   >
   > <font color='Apricot'>优点：</font> 基于RabbitMQ的死信队列，可以实现延迟消息，非常灵活的实现定时关单，并且借助RabbitMQ的集群扩展性，可以实现高可用，以及处理大并发量。
   >
   > <font color='Apricot'>缺点：</font> 
   >
   > 1. 可能存在消息阻塞，因为队列是先进先出的，而且每次只会判断队头的消息是否过期，那么，如果队头的消息时间很长，一直都不过期，那么就会阻塞整个队列，这时候即使排在他后面的消息过期了，那么也会被一直阻塞。
   > 2. 方案比较复杂，不仅要依赖RabbitMQ，而且还需要声明很多队列(exchange)出来，增加系统的复杂度

7. Redis过期监听

   > <font color='Apricot'>实现方式：</font>
   >
   > 在 redis.conf 中，加入一条配置notify-keyspace-events Ex开启过期监听，然后再代码中实现一个KeyExpirationEventMessageListener，就可以监听key的过期消息了。这样就可以在接收到过期消息的时候，进行订单的关单操作。
   >
   > <font color='RedOrange'>这个方案不建议大家使用，是因为Redis官网上明确的说过，Redis并不保证Key在过期的时候就能被立即删除，更不保证这个消息能被立即发出。所以，消息延迟是必然存在的，随着数据量越大延迟越长，延迟个几分钟都是常事儿。而且，在Redis 5.0之前，这个消息是通过PUB/SUB模式发出的，他不会做持久化，至于你有没有接到，有没有消费成功，他不管。也就是说，如果发消息的时候，你的客户端挂了，之后再恢复的话，这个消息你就彻底丢失了。 （在Redis 5.0之后，因为引入了Stream，是可以用来做延迟消息队列的。）</font>

8. Redis的zset

   zset是一个有序集合，每一个元素(member)都关联了一个 score，可以通过 score 排序来取集合中的值。

   > <font color='Apricot'>实现方式：</font>
   >
   > 我们将订单超时时间的时间戳（下单时间+超时时长）与订单号分别设置为 score 和 member。这样redis会对zset按照score延时时间进行排序。然后我们再开启Redis扫描任务，获取”当前时间 > score”的延时任务，扫描到之后取出订单号，然后查询到订单进行关单操作即可。
   >
   > <font color='Apricot'>优点：</font> 可以借助redis的持久化、高可用机制。避免数据丢失。
   >
   > <font color='Apricot'>缺点：</font> 在高并发场景中，有可能有多个消费者同时获取到同一个订单号，一般采用加分布式锁解决，但是这样做也会降低吞吐型。

   在大多数业务场景下，如果幂等性做得好的，多个消费者取到同一个订单号也无妨。

9. Redisson

   Redission中定义了分布式延迟队列RDelayedQueue，这是一种基于 zset 结构实现的延时队列，它允许以指定的延迟时长将元素放到目标队列中。其实就是在 zset 的基础上增加了一个基于内存的延迟队列。

   > <font color='Apricot'>实现方式：</font> 当我们要添加一个数据到延迟队列的时候，redission会把数据+超时时间放到zset中，并且起一个延时任务，当任务到期的时候，再去zset中把数据取出来，返回给客户端使用。
   >
   > <font color='Apricot'>优点：</font> 基于Redisson的实现方式，是可以解决基于zset方案中的并发重复问题的，而且还能实现方式也比较简单，稳定性、性能都比较高。

## 总结

<font color='Chestnut Red'>**实现的复杂度上**</font>（包含用到的框架的依赖及部署）：

Redission > RabbitMQ死信队列 > RocketMQ延迟消息 ≈ Redis的zset > Redis过期监听 ≈ kafka时间轮 > 定时任务 > Netty的时间轮 > JDK自带的DelayQueue

<font color='Chestnut Red'>**方案的完整性：**</font>

Redission \> kafka时间轮 > Redis的zset ≈ RocketMQ延迟消息 ≈ RabbitMQ死信队列 > Redis过期监听 > 定时任务 > Netty的时间轮 > JDK自带的DelayQueue

<font color='Chestnut Red'>**不同的场景中也适合不同的方案：**</font>

- 单体应用，业务量不大：Netty的时间轮、JDK自带的DelayQueue、定时任务
- 分布式应用，业务量不大：Redis过期监听、RabbitMQ死信队列、Redis的zset、定时任务
- 分布式应用，业务量大、并发高：Redission、kafka时间轮、RocketMQ延迟消息

总体考虑的话，考虑到成本，方案完整性、以及方案的复杂度，还有用到的第三方框架的流行度来说，<font color='Peach'>个人比较建议优先考虑 Redission+Redis、Redis的zset、RocketMQ延迟消息等方案。</font>

# 敏感词库设计

可参考https://www.jianshu.com/p/c511a448609e

# CSRF

即跨站请求伪造攻击。CSRF是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。可以简单的理解为：攻击者可以盗用登陆信息，以你的身份模拟发送各种请求对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。

## 原理

CSRF攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
1. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
1. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
1. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
1. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。

## CSRF 攻击的三个条件

1. 用户已经登录了站点 A，并在本地记录了 Cookie
2. 在用户没有登出站点 A 的情况下（也就是 Cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。
3. 站点 A 没有做任何 CSRF 防御

## 防御方法

### CSRF漏洞检测

检测CSRF漏洞最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。

CSRF漏洞检测工具如CSRFTester，CSRF Request Builder等。

以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。

### 防御CSRF攻击

CSRF 的防御可以从<font color='RedOrange'>服务端</font>和<font color='RedOrange'>客户端</font>两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。

服务端的预防 CSRF 攻击的方式方法有多种，主要从以下两个方面入手： 1、正确使用 GET，POST 请求和 Cookie；2、在非 GET 请求中增加 token并验证

1. <font color='RedOrange'>遵循标准的GET 动作</font> 

   只允许GET请求检索数据，但是不允许它修改服务器上的任何数据。这个修改可以防止利用 {img} 标签或者其它的类型的 GET 请求的 CSRF 攻击。另外，这个建议遵循 RFC 2616(HTTP/1.1)：具体说来，按照约定，GET 和 HEAD 方法不应该进行检索之外的动作。这些方法应该被认为是“安全的”。虽然这个保护措施无法阻止 CSRF 本身，因为攻击者可以使用 POST 请求，但是它却可以与(2)结合来全面防止 CSRF 漏洞。这里，我们假定对手无法修改用户的 Cookie。

2. <font color='RedOrange'>为页面增加随机数</font>

   当用户访问站点时，该站点应该生成一个（密码上很强壮的）伪随机值，并在用户的计算机上将其设为 Cookie。站点应该要求每个表单都包含该伪随机值（作为表单值和 Cookie 值）。当一个 POST 请求被发给站点时，只有表单值和 Cookie 值相同时，该请求才会被认为是有效的。当攻击者以一个用户的名义提交表单时，他只能修改该表单的值。攻击者不能读取任何发自该服务器的数据或者修改 Cookie 值，这是同源策略的缘故。这意味着，虽然攻击者可以用表单发送任何他想要的值，但是他却不能修改或者读取存储在该 Cookie 中的值。因为 Cookie 值和表单值必须是相同的，所以除非攻击者能猜出该伪随机值，否则他就无法成功地提交表单。

3. <font color='RedOrange'>在非 GET 请求中增加 token并验证</font>

   CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。
   这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。

4. <font color='RedOrange'>验证HTTP Referer字段</font>

   根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如上文中用户User想要在网站WebA中进行转账操作，那么用户User

   1. 必须先登录WabA
   2. 然后再通过点击页面上的按钮出发转账事件

   这时该转帐请求的 Referer 值就会是转账按钮所在的页面的URL，而如果黑客要对银行网站实施 CSRF攻击，他只能在他自己的网站构造请求，当用户User通过黑客的网站发送请求到WebA时，该请求的 Referer 是指向黑客自己的网站。
   因此，要防御 CSRF 攻击，网站WebA只需要对于每一个转账请求验证其 Referer 值，如果是以网站WebA的网址开头的域名，则说明该请求是来自WebA自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。
