# 设计模式

设计模式（Design pattern）是一套被**反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结**。使用设计模式是为了**提高代码可重用性、增强可维护性、保证代码可靠性，并帮助开发者建立通用高效的沟通方式**。设计模式不是具体的代码实现，而是解决特定问题的指导性方案。 

# 设计模式的六大原则

**1、<font color='blue'>开闭原则（Open Close Principle）</font>**

- **核心**：**对扩展开放，对修改关闭**。
- 通过抽象（接口或抽象类）和继承机制实现扩展性，避免直接修改已有代码。
  **补充**：策略模式、装饰器模式等是实现该原则的典型方式。

**2、<font color='blue'>里氏代换原则（Liskov Substitution Principle）</font>**

- **核心**：**子类必须能够完全替代父类，且不影响程序的正确性**。
  **补充**：LSP是继承复用的基石，只有当衍生类可以替换掉基类，程序功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。**实现“开-闭”原则的关键步骤就是抽象化**。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、<font color='blue'>依赖倒转原则（Dependence Inversion Principle）</font>**

- 核心：抽象不应依赖细节，细节应依赖抽象。

  扩展：

  - 高层模块（业务逻辑）和低层模块（具体实现）都应依赖于抽象。
  - 通过依赖注入（如构造函数注入、接口注入）降低耦合。

  **依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。**这个是开闭原则的基础。

**4、<font color='blue'>接口隔离原则（Interface Segregation Principle）</font>**

- **核心**：**客户端不应被迫依赖其不使用的接口**。
  **补充**：将臃肿的接口拆分为更小、更具体的接口，避免实现类冗余方法（如 `Animal` 接口拆分为 `Flyable` 和 `Swimmable`）。

**5、<font color='blue'>迪米特法则（最少知道原则）（Demeter Principle）</font>**

- **核心**：**一个对象应尽可能少地与其他对象发生相互作用**。
  **补充**：“只与直接朋友通信”，即通过组件化、中间层等方式解耦。(“朋友”指成员变量、方法参数和返回值中的对象，而非陌生对象。)

**6、<font color='blue'>合成复用原则（Composite Reuse Principle）</font>**

- **核心**：**优先使用组合（Composition）或聚合（Aggregation），而不是继承**。
  **补充**：组合通过持有其他对象实现功能复用，避免继承带来的强耦合（如 `Car` 类包含 `Engine` 成员变量）。

# 设计模式的三大类

1. **创建型模式（5种）**

   - 关注对象的创建机制：**工厂方法**、**抽象工厂**、**单例**、**建造者**、**原型**。

   - **关键**：解耦对象的创建与使用逻辑。

2. **结构型模式（7种）**

   - 关注类与对象的组合方式：**适配器**、**装饰器**、**代理**、**外观**、**桥接**、**组合**、**享元**。

   - **关键**：通过灵活结构增强扩展性（如适配器兼容不同接口）。

3. **行为型模式（11种）**

   - 关注对象间的交互与责任分配：**策略**、**模板方法**、**观察者**、**迭代器**、**责任链**、**命令**、**备忘录**、**状态**、**访问者**、**中介者**、**解释器**。

   - **关键**：将算法或行为抽象化（如策略模式封装可替换的算法）。

<img src="https://img-blog.csdnimg.cn/20190307193652259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1Z2FyX25vMQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />

**根据模式是主要用于类上还是主要用于对象**上来分，这种方式可分为类模式和对象模式两种。

1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。

| **范围\目的** | **创建型模式**               | **结构型模式**                     |                        **行为型模式**                        |
| :------------ | :--------------------------- | :--------------------------------- | :----------------------------------------------------------: |
| **类模式**    | 工厂方法                     | （类）适配器                       |                       模板方法、解释器                       |
| **对象模式**  | 单例、原型、抽象工厂、建造者 | 代理、桥接、装饰、外观、享元、组合 | 策略、命令、责任链、状态、观察者、中介者、迭代器、访问者、备忘录 |

# 23种设计模式

## 访问者模式

**核心**：
 访问者模式（Visitor Pattern）是一种**行为型设计模式**，它允许我们在不修改已有对象结构的前提下，新增新的操作行为。

**目的**：

- 当系统存在**稳定的对象结构**，但对这些对象的操作经常变化时，访问者模式非常适合。
- 将**数据结构**与**行为操作**解耦，遵循“开闭原则”（对扩展开放，对修改封闭）。

**主要组成部分**：访问者模式主要由 **5 个核心角色** 组成：

1. **Element（元素）接口**

   - 定义了**接受访问者**的方法：`accept(Visitor visitor)`
   - 由具体的元素类（ConcreteElement）实现。

2. **ConcreteElement（具体元素）**

   - 实现 `accept` 方法，**反向调用访问者的 visit 方法**，并将自己传递过去（双重分派）。

   - 可以是系统中的各种对象（如：File、Directory、Node 等）。

3. **Visitor（访问者）接口**

   - 声明了**对每个具体元素进行访问的方法**，如：`visit(File file)`、`visit(Directory dir)`。

4. **ConcreteVisitor（具体访问者）**

   - 实现 `Visitor` 接口，**定义对每种元素的具体操作**。

   - 每种新的操作对应一个新的访问者。

5. **Object Structure（对象结构）**

   - 元素的容器，如树、列表或集合，提供**遍历元素的方法**并调用 `accept`。

| 特性               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| **双重分派**       | `accept(visitor)` ➡ `visitor.visit(this)`，解决单分派局限，运行时根据对象类型动态分派 |
| **符合开闭原则**   | **扩展操作**时只需新增访问者类，**不修改元素类**             |
| **解耦数据和行为** | 对象结构负责存储，访问者负责行为                             |
| **支持多种操作**   | 如：打印、统计、检查、导出等，不影响对象结构                 |



<font color="red">**创建型模式(5种)：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。**</font>

## 单例模式

单例（Singleton）模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式有三个要点：

1. 构造方法私有化；
2. 实例化的变量引用私有化；
3. 获取实例的方法共有

**好处:**

- 对于频繁使用的对象，可以省略创建对象所花费的时间
- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低

> 为什么不使用全局变量确保一个类只有一个实例呢？

全局变量分为静态变量和实例变量，静态变量也可以保证该类的实例只存在一个。
只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。

但是，如果说这个对象非常消耗资源，而且程序某次的执行中一直没用，这样就造成了资源的浪费。利用单例模式的话，我们就可以实现在需要使用时才创建对象，这样就避免了不必要的资源浪费。 不仅仅是因为这个原因，在程序中我们要尽量避免全局变量的使用，大量使用全局变量给程序的调试、维护等带来困难。

> 单例的模式的实现

- 饿汉方式：指全局的单例实例在类装载时构建
- 懒汉方式：指全局的单例实例在第一次被使用时构建。

不管是那种创建方式，它们通常都存在下面几点相似处：

- 单例类必须要有一个 `private` 访问级别的构造函数，只有这样，才能确保单例不会在系统中的其他代码内被实例化;

- `instance` 成员变量和 `uniqueInstance` 方法必须是 `static` 的。



1. 饿汉方式(线程安全)

   所谓 **“饿汉方式”** 就是说`JVM`在加载这个类时就马上创建此唯一的单例实例，线程安全但可能浪费内存，典型的空间换时间

   ~~~java
   public class Singleton {
       // 私有构造器
       private Singleton() {}
       
       // 类加载时就创建实例
       private static final Singleton instance = new Singleton();
       
       // 提供公共访问点
       public static Singleton getInstance() {
           return instance;
       }
   }
   ~~~

   

2. 懒汉式（非线程安全和`synchronized`关键字线程安全版本 ）

   “ 懒汉式” 就是单例实例在第一次被使用时构建，而不是在`JVM`在加载这个类时就马上创建此唯一的单例实例。

   ~~~java
   // 非线程安全版本
   public class Singleton {
       private static Singleton instance;
       
       private Singleton() {}
       
       public static Singleton getInstance() {
           if (instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ~~~

   上面这种方式很明显是线程不安全的，如果多个线程同时访问`getInstance()`方法时就会出现问题。如果想要保证线程安全，一种比较常见的方式就是在`getInstance() `方法前加上`synchronized`关键字

   ~~~java
   // 线程安全版本
   public class Singleton {
       private static Singleton instance;
       
       private Singleton() {}
       
       public static synchronized Singleton getInstance() {
           if (instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ~~~

   `synchronized`关键字偏重量级锁。虽然在`JavaSE1.6`之后`synchronized`关键字进行了优化主要包括：为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后，执行效率有了显著提升。

   但是在程序中每次使用`getInstance()` 都要经过`synchronized`加锁这一层，这会增加`getInstance()`方法的时间消费，而且还可能会发生阻塞。下面的 双重检查加锁版本 就是为了解决这个问题而存在的。

3. 懒汉式(双重检查加锁版本)

   **利用双重检查加锁（double-checked locking），首先检查是否实例已经创建，如果尚未创建，“才”进行同步。这样以来，只有一次同步。**

   这种方式相比于使用`synchronized`关键字的方法，可以大大减少`getInstance() `的时间消费。

   ~~~java
   public class Singleton {
       private volatile static Singleton instance;
       
       private Singleton() {}
       
       public static Singleton getInstance() {
           if (instance == null) {
               synchronized (Singleton.class) {
                   if (instance == null) {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ~~~

   

4. 懒汉式（静态内部类）

   **线程安全且延迟加载**

   **JVM 类加载机制**：`SingletonHolder` 是一个静态内部类，它在 `getInstance()` 第一次显式调用时才会被**加载和初始化**，保证**延迟加载**。

   **类加载的线程安全性**：JVM 的类加载机制**天然保证线程安全**，不会有多线程下的重复创建问题。

   **单一实例**：`INSTANCE` 是 `static final`，保证只有一个实例。

   ~~~java
   public class Singleton {
       private Singleton() {}
       
       private static class SingletonHolder {
           private static final Singleton INSTANCE = new Singleton();
       }
       
       public static Singleton getInstance() {
           return SingletonHolder.INSTANCE;
       }
   }
   ~~~

   

5. 饿汉式（枚举方式）

   这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。 **它更简洁，自动支持序列化机制，绝对防止多次实例化** （如果单例类实现了`Serializable`接口，默认情况下每次反序列化总会创建一个新的实例对象
   
   ~~~java
   public enum Singleton {
       INSTANCE;
       
       // 如果需要其他方法
       public void doSomething() {
           // 业务方法
       }
   }
   
   // 使用方式
   Singleton.INSTANCE.doSomething();
   ~~~
   
   

## 工厂模式

工厂设计模式是一种创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们**创建对象时不会对客户端暴露创建逻辑**，并且是通过**使用一个共同的接口来指向新创建的对象**。

> 针对的问题

在面向对象编程中，最常用的方法是`new`一个操作符产生一个对象实例，`new`对象操作符就是用来构造对象实例的，但是在一些情况下，`new`操作符直接生成对象会带来一些问题，举例说，许多类型对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助功能的对象，这些情况下，对象的建立就是一个过程，不仅是一个操作。

>  工厂模式类型

工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到灵活性的目的。

1. 简单工厂模式

2. 工厂方法模式

3. 抽象工厂模式

   一般将简单工厂模式看为工厂方法模式的一种特例，二者归为一类。

> 简单工厂模式角色组成

1. **工厂类角色**：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品
2. **抽象产品角色**：它一般是具体产品继承的父类或者实现的接口。
3. **具体产品角色**：工厂类所创建的对象就是此角色的实例。在`java`中由一个具体类实现。

> 工厂方法模式角色组成

1. 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在`java`中它由抽象类或者接口来实现。

2. 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。

3. 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在`java`中一般有抽象类或者接口来实现。

4. 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在`java`中由具体的类来实现。

工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的上帝类，分担了对象承受的压力

工厂方法模式实现时，客户端需要决定实例化哪一个工厂来创建对象，工厂方法把**简单工厂的内部逻辑移到了客户端**代码来执行。

> 抽象工厂模式

抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。

抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。就是一个工厂里放一些相关的类，使工厂数减少。

最大的好处便是易于交换产品系列，其次是让具体的创建实例过程与客户端分离，客户端通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离。不会出现在客户代码中

**分析**

抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。

## 策略模式

把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。
比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。

**适用情况**
许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。
当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。
一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的`Strategy`类中以代替这些条件语句。

**优点**
1、可以动态的改变对象的行为
**缺点**
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2、策略模式将造成产生很多策略类

**组成**
环境类(`Context`):用一个`ConcreteStrategy`对象来配置。维护一个对`Strategy`对象的引用。可定义一个接口来让`Strategy`访问它的数据。
抽象策略类(`Strategy`):定义所有支持的算法的公共接口。 `Context`使用这个接口来调用某`ConcreteStrategy`定义的算法。
具体策略类(`ConcreteStrategy`):以`Strategy`接口实现某具体算法。

## 观察者模式

观察者模式（又被称为发布-订阅（`Publish/Subscribe`）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

> 观察者模式中有如下角色：

`Subject`：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
`ConcreteSubject`：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
`Observer`：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
`ConcrereObserver`：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。

**使用场景**

1. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。

2. 事件多级触发场景。

3. 跨系统的消息交换场景，如消息队列、事件总线的处理机制。

**优点**
解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。

**缺点**
在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。