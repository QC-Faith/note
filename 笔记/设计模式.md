# 设计模式

设计模式（Design pattern）是一套被**反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。**使用设计模式是为了<font color='red'>可重用代码、让代码更容易被他人理解、保证代码可靠性</font>。 

# 设计模式的六大原则

**1、<font color='blue'>开闭原则（Open Close Principle）</font>**

开闭原则就是说 **对扩展开放，对修改关闭** 。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

**2、<font color='blue'>里氏代换原则（Liskov Substitution Principle）</font>**

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。**实现“开-闭”原则的关键步骤就是抽象化**。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、<font color='blue'>依赖倒转原则（Dependence Inversion Principle）</font>**

这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、<font color='blue'>接口隔离原则（Interface Segregation Principle）</font>**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：**降低依赖，降低耦合**。

**5、<font color='blue'>迪米特法则（最少知道原则）（Demeter Principle）</font>**

一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。解耦

**6、<font color='blue'>合成复用原则（Composite Reuse Principle）</font>**

原则是尽量使用合成/聚合的方式，而不是使用继承。

**设计模式原则详细描述请见：**http://www.cnblogs.com/pony1223/p/7594803.html

# 设计模式的三大类

**创建型模式(5种) ：**工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

**结构型模式(7种) ：**适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

**行为型模式(11种) ：**策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

<img src="https://img-blog.csdnimg.cn/20190307193652259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1Z2FyX25vMQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />

**根据模式是主要用于类上还是主要用于对象**上来分，这种方式可分为类模式和对象模式两种。

1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。

| 范围\目的 | 创建型模式                | 结构型模式                                  |                        行为型模式                        |
| :-------- | :------------------------ | :------------------------------------------ | :------------------------------------------------------: |
| 类模式    | 工厂方法                  | (类）适配器                                 |                     模板方法、解释器                     |
| 对象模式  | 单例 原型 抽象工厂 建造者 | 代理 (对象）适配器 桥接 装饰 外观 享元 组合 | 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 |

# 23种设计模式

<font color="red">**创建型模式(5种)：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。**</font>

## 单例模式

单例（Singleton）模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式有三个要点：

1. 构造方法私有化；
2. 实例化的变量引用私有化；
3. 获取实例的方法共有

**好处:**

- 对于频繁使用的对象，可以省略创建对象所花费的时间
- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低

> 为什么不使用全局变量确保一个类只有一个实例呢？

全局变量分为静态变量和实例变量，静态变量也可以保证该类的实例只存在一个。
只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。

但是，如果说这个对象非常消耗资源，而且程序某次的执行中一直没用，这样就造成了资源的浪费。利用单例模式的话，我们就可以实现在需要使用时才创建对象，这样就避免了不必要的资源浪费。 不仅仅是因为这个原因，在程序中我们要尽量避免全局变量的使用，大量使用全局变量给程序的调试、维护等带来困难。

> 单例的模式的实现

- 饿汉方式：指全局的单例实例在类装载时构建
- 懒汉方式：指全局的单例实例在第一次被使用时构建。

不管是那种创建方式，它们通常都存在下面几点相似处：

- 单例类必须要有一个 `private` 访问级别的构造函数，只有这样，才能确保单例不会在系统中的其他代码内被实例化;

- `instance` 成员变量和 `uniqueInstance` 方法必须是 `static` 的。



1. 饿汉方式(线程安全)

   所谓 **“饿汉方式”** 就是说`JVM`在加载这个类时就马上创建此唯一的单例实例，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。

2. 懒汉式（非线程安全和`synchronized`关键字线程安全版本 ）

   所谓 “ 懒汉式” 就是说单例实例在第一次被使用时构建，而不是在`JVM`在加载这个类时就马上创建此唯一的单例实例。

   但是上面这种方式很明显是线程不安全的，如果多个线程同时访问`getInstance()`方法时就会出现问题。如果想要保证线程安全，一种比较常见的方式就是在`getInstance() `方法前加上`synchronized`关键字

   我们知道`synchronized`关键字偏重量级锁。虽然在`JavaSE1.6`之后`synchronized`关键字进行了主要包括：为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升。

   但是在程序中每次使用`getInstance()` 都要经过`synchronized`加锁这一层，这会增加`getInstance()`方法的时间消费，而且还可能会发生阻塞。我们下面介绍到的 双重检查加锁版本 就是为了解决这个问题而存在的。

3. 懒汉式(双重检查加锁版本)

   **利用双重检查加锁（double-checked locking），首先检查是否实例已经创建，如果尚未创建，“才”进行同步。这样以来，只有一次同步，这正是我们想要的效果。**

   很明显，这种方式相比于使用`synchronized`关键字的方法，可以大大减少`getInstance() `的时间消费。

4. 懒汉式（登记式/静态内部类方式）

   **静态内部实现的单例是懒加载的且线程安全。**

   只有通过显式调用 `getInstance` 方法时，才会显式装载 `SingletonHolder` 类，从而实例化 `instance`（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。

5. 饿汉式（枚举方式）

   这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。 **它更简洁，自动支持序列化机制，绝对防止多次实例化** （如果单例类实现了`Serializable`接口，默认情况下每次反序列化总会创建一个新的实例对象

## 工厂模式

工厂设计模式是一种创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们**创建对象时不会对客户端暴露创建逻辑**，并且是通过**使用一个共同的接口来指向新创建的对象**。

> 针对的问题

在面向对象编程中，最常用的方法是`new`一个操作符产生一个对象实例，`new`对象操作符就是用来构造对象实例的，但是在一些情况下，`new`操作符直接生成对象会带来一些问题，举例说，许多类型对象的创建都需要一系列的步骤，可能需要计算或取得对象的初始设置，选择生成哪个子对象实例，或者在生成需要的对象之前必须先生成一些辅助功能的对象，这些情况下，对象的建立就是一个过程，不仅是一个操作。

>  工厂模式类型

工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到灵活性的目的。

1. 简单工厂模式

2. 工厂方法模式

3. 抽象工厂模式

   一般将简单工厂模式看为工厂方法模式的一种特例，二者归为一类。

> 简单工厂模式角色组成

1. **工厂类角色**：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品
2. **抽象产品角色**：它一般是具体产品继承的父类或者实现的接口。
3. **具体产品角色**：工厂类所创建的对象就是此角色的实例。在`java`中由一个具体类实现。

> 工厂方法模式角色组成

1. 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在`java`中它由抽象类或者接口来实现。

2. 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。

3. 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在`java`中一般有抽象类或者接口来实现。

4. 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在`java`中由具体的类来实现。

工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的上帝类，分担了对象承受的压力

工厂方法模式实现时，客户端需要决定实例化哪一个工厂来创建对象，工厂方法把**简单工厂的内部逻辑移到了客户端**代码来执行。

> 抽象工厂模式

抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。

抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。就是一个工厂里放一些相关的类，使工厂数减少。

最大的好处便是易于交换产品系列，其次是让具体的创建实例过程与客户端分离，客户端通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离。不会出现在客户代码中

**分析**

抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。

## 策略模式

把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。
比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。

**适用情况**
许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。
当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。
一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的`Strategy`类中以代替这些条件语句。

**优点**
1、可以动态的改变对象的行为
**缺点**
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2、策略模式将造成产生很多策略类

**组成**
环境类(`Context`):用一个`ConcreteStrategy`对象来配置。维护一个对`Strategy`对象的引用。可定义一个接口来让`Strategy`访问它的数据。
抽象策略类(`Strategy`):定义所有支持的算法的公共接口。 `Context`使用这个接口来调用某`ConcreteStrategy`定义的算法。
具体策略类(`ConcreteStrategy`):以`Strategy`接口实现某具体算法。

## 观察者模式

观察者模式（又被称为发布-订阅（`Publish/Subscribe`）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

> 观察者模式中有如下角色：

`Subject`：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
`ConcreteSubject`：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
`Observer`：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
`ConcrereObserver`：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。

**使用场景**

1. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。

2. 事件多级触发场景。

3. 跨系统的消息交换场景，如消息队列、事件总线的处理机制。

**优点**
解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。

**缺点**
在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。