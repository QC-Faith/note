### java基础部分



#### ArrayList

底层包装了一个object数组，查询效率高o(1)，因为arrayList底层是数组，内存具有连续性，所以get的性能很好



arrayList可以一直保证内存的连续性吗？



list的扩容机制确保了每次的分配都是连续的内存，因为扩容时会先划定新的内存区域，将老的数据coyp过去

初始容量为10，扩容为1.5倍

这样原数据在下次gc发生时就会被回收





##### 线程安全的list

ConcurrentLinkedDeque

实现了一个双向链表，使用cas进行控制，性能最好



Collections.synchronizedList 性能较差



CopyOnWriteArrayList 修改是要重新复制整个数组，适合写操作少的情况，就是通过复制保证线程安全（也是服了）







#### HashMap



在hash碰撞的时候时间复杂度会变为o(log n) n是红黑树节点的数量

没有碰撞的时候才是o(1)





初始容量16，负载因子0.75

put 先对key值进行hash，根据hash值进行length-1的取模，从而得到所在链表的位置

但是put方法不是原子性的不能保证线程安全



hashmap通过控制容量都为2的幂次方保证了取模不会超出容量



长度通常是2的幂次方，例如16、32、64等。由于这些长度都是2的幂次方，所以减1后的二进制位就全部是1，这样做的目的是保证取模的结果不会超出数组范围，即确保了计算出的索引值在合理的范围内。





扩容：

创建新的node数组，长度为之前的两倍

遍历数组，重新进行put操作



链表长度超过8后转变为红黑树



##### 红黑树：


红黑树是一种自平衡的二叉搜索树，它在每个节点上添加了一个额外的属性表示节点的颜色，可以是红色或黑色。红黑树满足以下性质：

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色。
3. 每个叶子节点（NIL 节点，即空节点）是黑色。
4. 如果一个节点是红色的，则其子节点必须是黑色的（不能有两个连续的红色节点）。
5. 从任意节点到其每个叶子节点的路径包含相同数量的黑色节点（黑高相同）。





如果有一个key为“王启明”,并且造成了哈希冲突进入红黑树进行搜索，使用key值与根节点比较，如果大于向右继续查找，小于向左继续查找，直到key值一致



##### 线程安全的HashMap

ConcurrentHashMap  使用segMent分段锁，每个锁就锁16个数组，使用了cas中的ReentrantLock，ReadWriteLock进行实现，锁的粒度小所以性能好



ConcurrentSkipListMap 使用跳表加速了查询效率



什么是跳表？

就是多级索引加快了查找效率，例如一个node中有关联同级down，也有nextnode

1. `next`指针：指向同一层级中的下一个节点，用于沿着同一层级进行顺序遍历。
2. `down`指针：指向下一层级的对应节点，用于向下一层级跳跃。
3. `right`指针：与`next`指针类似，也是指向同一层级中的下一个节点，但用于更高层级的节点。跳表的每一层级都有一个头节点，`right`指针指向下一个层级的头节点。

属于一种分层搜索算法的实现































