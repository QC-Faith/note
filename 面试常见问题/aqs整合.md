AQS



关键元素：

状态变量 state 通过volatile 修饰

等待队列 Node  是一个双向链表

1. **Thread**：表示当前被阻塞的线程。每个节点都会关联一个被阻塞的线程，以便在适当的时候唤醒该线程。
2. **prev**：指向前一个节点的引用。在等待队列中，节点是按照 FIFO（先进先出）的顺序排列的，prev 指向前一个节点，用于维护等待队列的链表结构。
3. **next**：指向后一个节点的引用。同样，next 指向后一个节点，用于维护等待队列的链表结构。
4. **status**：表示节点的状态。通常情况下，节点的状态有以下几种：
   - **CANCELLED**：表示节点已取消。当一个线程不再需要等待时，可能会取消自己的节点。
   - **SIGNAL**：表示节点需要唤醒后继节点。当一个节点需要唤醒它的后继节点时，会将自己的状态设置为 SIGNAL。
   - **CONDITION**：表示节点在条件队列中。如果节点是由条件变量的 await 方法加入到等待队列中的，它的状态会被设置为 CONDITION。
   - **PROPAGATE**：表示共享模式下的传播状态。用于在共享锁中进行线程之间的通信。
   - **0（默认状态）**：表示节点正常等待。节点刚创建时的默认状态。



常用实现

1. **ReentrantLock**：可重入锁，是基于 AQS 实现的独占锁。它提供了与 synchronized 关键字类似的功能，但更加灵活和可控。
2. **ReentrantReadWriteLock**：可重入读写锁，也是基于 AQS 实现的。与独占锁不同，读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。
3. **Semaphore**：信号量，用于控制同时访问某个特定资源的线程数量。它基于 AQS 的共享模式，可以用来限制并发访问的数量。
4. **CountDownLatch**：倒计时门闩，用于实现线程等待其他线程完成某些操作后再继续执行。它基于 AQS 的共享模式，允许一个或多个线程等待多个事件的发生。
5. **CyclicBarrier**：循环屏障，类似于倒计时门闩，但可以重复使用。它基于 AQS 的共享模式，用于多个线程之间相互等待，直到所有线程都到达屏障点。
6. **Phaser**：分阶段屏障，也是用于多个线程协作的同步器。它支持多个阶段，每个阶段都有多个参与者，线程可以在阶段间同步等待。
7. **Condition**：条件对象，用于实现线程间的条件等待和通知。它是基于 AQS 实现的，与锁对象（如 ReentrantLock）关联。



## ReentrantLock

可实现公平锁或非公平锁，非公平锁自动获取node next下个节点，公平时使用cas让之后的节点全部参与

根据构造方法可指定公平或非公平



公平锁和非公平锁的区别？

非公平锁能有效利用cpu时间片，减少cup空闲状态时间

公平锁慢，因为要等线程挂起的延时



什么是cpu时间片？

thread.setPriority(Thread.MAX_PRIORITY); 可以设置时间片

把时间片理解为一个线程在执行任务时需要cup给其分配资源进行执行任务就可以了

时间片的大小是不可以指定的，但可以通过优先级调整来活的资源的倾斜



reentrantLock是如何支持重入的呢？



在集成aqs的类中进行了扩展，新增参数holdCount用于记录每次线程的持有数

会通过 CAS 操作将 `state` 设置为 1，并将 `Thread` 设置为当前线程，并将 `holdCount` 设置为 1。此后，如果同一个线程再次获取锁，会直接将 `holdCount` 加 1，并不会重新竞争锁。当线程释放锁时，只有当 `holdCount` 减到 0 时，才会真正释放锁。





reentranLock和synchronized 的区别？

synchronized 不支持公平锁

ReentrantLock的加锁、解锁操作都是需要手动进行

synchronized 不支持tryLock尝试获取锁的操作





synchronized 为什么不支持公平锁？

因为对性能的追求





## CountDownLatch

同步辅助

简单将就是可以让几个线程同事等待，直到其他线程也完成了任务，内部维护了一个程序计数器保证原子性



可以实现同上上传五个文件，五个文件全部上传成功再修改数据库上传状态

常用api await()，countDown()

await可传入等待时间自己在业务内进行处理



## Semaphore



信号量

- 用于保证同一时间并发访问线程的数目。

可以限制当前线程的总大小数，通过构造函数传入，api提供了wait()，release()，tryAcquire()

可以用来管理连接池



其实也是通过计数器来实现的，表示当前的许可数量，release是计数器+1，Acquire-1；



1. `acquire()`: 获取一个许可证，如果没有可用的许可证，则会阻塞当前线程，直到有可用的许可证为止。
2. `acquire(int permits)`: 获取指定数量的许可证，如果没有足够数量的许可证，则会阻塞当前线程，直到有足够数量的许可证为止。
3. `release()`: 释放一个许可证，使其可供其他线程使用。
4. `release(int permits)`: 释放指定数量的许可证，使其可供其他线程使用。
5. `tryAcquire()`: 尝试获取一个许可证，如果成功获取则返回 true，否则返回 false，不会阻塞当前线程。
6. `tryAcquire(int permits)`: 尝试获取指定数量的许可证，如果成功获取则返回 true，否则返回 false，不会阻塞当前线程。
7. `availablePermits()`: 返回当前可用的许可证数量。
8. `tryAcquire(long timeout, TimeUnit unit)`: 在指定的时间内尝试获取一个许可证，如果成功获取则返回 true，否则返回 false，不会阻塞当前线程超过指定的时间。



## CyclicBarrier



和CountDownLatch一样都是使用程序计数器来实现，但是支持reset进行重置，支持循环使用

所以属于循环屏障



CyclicBarrier是通过ReentrantLock的"独占锁"和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现







